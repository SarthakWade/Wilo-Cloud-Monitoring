#!/usr/bin/env python3
"""
Enhanced WebSocket server with high-speed sensor service integration
"""

import asyncio
import websockets
import json
import os
import csv
import zipfile
import tempfile
from datetime import datetime
from pathlib import Path
from high_speed_sensor_service import HighSpeedSensorService
import threading
from http.server import HTTPServer, SimpleHTTPRequestHandler
import socketserver
from urllib.parse import unquote
import shutil

class HighSpeedWebSocketServer:
    def __init__(self):
        self.clients = set()
        self.sensor_service = HighSpeedSensorService()
        self.running = False
        self.readings_dir = Path("readings")
        self.last_file_count = 0
        self.download_dir = Path("downloads")
        self.download_dir.mkdir(exist_ok=True)
        self.http_server = None
        self.http_port = 8766
        
    async def register_client(self, websocket):
        """Register a new WebSocket client"""
        self.clients.add(websocket)
        print(f"Client connected. Total clients: {len(self.clients)}")
        
        # Send initial status
        await self.send_status_update(websocket)
        
    async def unregister_client(self, websocket):
        """Unregister a WebSocket client"""
        if websocket in self.clients:
            self.clients.remove(websocket)
        print(f"Client disconnected. Total clients: {len(self.clients)}")
        
    async def load_csv_data(self, filename):
        """Load CSV data from file"""
        try:
            return self.sensor_service.load_csv_data(filename)
        except Exception as e:
            raise Exception(f"Error reading CSV file: {str(e)}")
    
    async def create_csv_zip_export(self):
        """Create a ZIP file containing all CSV files in their hierarchical structure"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        zip_filename = f"sensor_data_export_{timestamp}.zip"
        
        # Create ZIP file in downloads directory
        zip_path = self.download_dir / zip_filename
        
        print(f"Creating ZIP export at: {zip_path}")
        print(f"Scanning directory: {self.readings_dir}")
        
        file_count = 0
        
        # Check if readings directory exists
        if not self.readings_dir.exists():
            raise Exception(f"Readings directory {self.readings_dir} does not exist")
        
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # Add all CSV files maintaining the exact hierarchical structure
            csv_files = list(self.readings_dir.rglob("*.csv"))
            print(f"Found {len(csv_files)} CSV files to export")
            
            for csv_file in csv_files:
                if csv_file.is_file():
                    try:
                        # Get relative path from readings directory to maintain folder structure
                        relative_path = csv_file.relative_to(self.readings_dir)
                        # Add to ZIP with the full folder structure (Year/Month/Week/Day/file.csv)
                        zipf.write(csv_file, f"sensor_data/{relative_path}")
                        file_count += 1
                        print(f"Added to ZIP: sensor_data/{relative_path}")
                    except Exception as e:
                        print(f"Warning: Failed to add {csv_file} to ZIP: {e}")
                        continue
            
            # Add a summary file at the root of the ZIP
            summary_content = f"""Wilo Sensor Data Export Summary
=================================
Export Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total Files: {file_count}
Data Structure: sensor_data/Year/Month/Week_N/Day/HHMMSS.csv

File Format:
- Time (ms): Milliseconds within file second (e.g., 0.223ms, 3.2122ms)
- Acceleration: m/sÂ² (float)

Directory Structure:
- Year: 4-digit year (e.g., 2024)
- Month: 2-digit month (e.g., 01-12)
- Week_N: Week number within the month (e.g., Week_1, Week_2, etc.)
- Day: 2-digit day (e.g., 01-31)
- HHMMSS.csv: Hour, minute, second of the data file

Generated by Wilo Cloud Monitoring System
"""
            zipf.writestr("README.txt", summary_content)
        
        print(f"ZIP file created successfully with {file_count} files")
        
        # Verify the ZIP file was created
        if not zip_path.exists():
            raise Exception("ZIP file was not created successfully")
        
        file_size = zip_path.stat().st_size
        print(f"ZIP file size: {file_size} bytes")
        
        # Create HTTP download URL
        download_url = f"http://localhost:{self.http_port}/{zip_filename}"
        
        return {
            'url': download_url,
            'filename': zip_filename,
            'file_count': file_count,
            'path': str(zip_path),
            'size': file_size
        }
    
    def start_http_server(self):
        """Start HTTP server to serve download files"""
        try:
            class DownloadHandler(SimpleHTTPRequestHandler):
                def __init__(self, *args, **kwargs):
                    # Set the directory to serve files from
                    self.downloads_dir = str(self.server.downloads_dir)
                    super().__init__(*args, directory=self.downloads_dir, **kwargs)
                
                def end_headers(self):
                    # Add headers for ZIP file downloads
                    if self.path.endswith('.zip'):
                        self.send_header('Content-Type', 'application/zip')
                        self.send_header('Content-Disposition', f'attachment; filename="{os.path.basename(self.path)}"')
                    super().end_headers()
                
                def log_message(self, format, *args):
                    # Suppress HTTP server logs
                    pass
            
            # Create a custom HTTPServer that passes the downloads directory
            class CustomHTTPServer(HTTPServer):
                def __init__(self, server_address, handler_class, downloads_dir):
                    self.downloads_dir = downloads_dir
                    super().__init__(server_address, handler_class)
            
            self.http_server = CustomHTTPServer(('localhost', self.http_port), DownloadHandler, self.download_dir)
            print(f"HTTP download server started on http://localhost:{self.http_port}")
            
            # Run HTTP server in a separate thread
            def run_server():
                self.http_server.serve_forever()
            
            http_thread = threading.Thread(target=run_server, daemon=True)
            http_thread.start()
            
        except Exception as e:
            print(f"Failed to start HTTP server: {e}")
    
    def stop_http_server(self):
        """Stop HTTP server"""
        if self.http_server:
            self.http_server.shutdown()
            self.http_server = None
    
    async def send_to_all_clients(self, message):
        if self.clients:
            disconnected = []
            for client in self.clients:
                try:
                    await client.send(message)
                except websockets.exceptions.ConnectionClosed:
                    disconnected.append(client)
                except Exception as e:
                    print(f"Error sending to client: {e}")
                    disconnected.append(client)
            
            # Remove disconnected clients
            for client in disconnected:
                self.clients.discard(client)
    
    async def send_status_update(self, websocket=None):
        """Send status update to client(s)"""
        status = self.sensor_service.get_status()
        
        status_message = {
            "type": "status",
            "data": {
                "connected": status['connected'],
                "sampling_rate": status['sampling_rate'],
                "total_samples": status['total_samples'],
                "csv_files": status['csv_stats']['total_files'],
                "latest_file": self.sensor_service.get_latest_file()
            }
        }
        
        message = json.dumps(status_message)
        
        if websocket:
            try:
                await websocket.send(message)
            except:
                pass
        else:
            await self.send_to_all_clients(message)
    
    async def handle_command(self, websocket, command_data):
        """Handle commands from frontend"""
        command = command_data.get('command')
        
        if command == 'get_status':
            await self.send_status_update(websocket)
            
        elif command == 'start_collection':
            self.sensor_service.start()
            await self.send_status_update()
            
        elif command == 'stop_collection':
            self.sensor_service.stop()
            await self.send_status_update()
            
        elif command == 'pause_collection':
            self.sensor_service.pause()
            await self.send_status_update()
            
        elif command == 'resume_collection':
            self.sensor_service.resume()
            await self.send_status_update()
            
        elif command == 'get_file_list':
            files = self.sensor_service.get_file_list()
            response = {
                "type": "file_list",
                "files": files  # Return full list; frontend can paginate if needed
            }
            await websocket.send(json.dumps(response))
            
        elif command == 'get_folder_structure':
            structure = self.sensor_service.get_folder_structure()
            response = {
                "type": "folder_structure",
                "structure": structure
            }
            await websocket.send(json.dumps(response))
            
        elif command == 'get_csv_data':
            filename = command_data.get('filename')
            if filename:
                try:
                    csv_data = await self.load_csv_data(filename)
                    response = {
                        "type": "csv_data",
                        "filename": filename,
                        "data": csv_data
                    }
                    await websocket.send(json.dumps(response))
                except Exception as e:
                    error_response = {
                        "type": "error",
                        "message": f"Failed to load CSV file {filename}: {str(e)}"
                    }
                    await websocket.send(json.dumps(error_response))
            else:
                error_response = {
                    "type": "error",
                    "message": "CSV filename not provided"
                }
                await websocket.send(json.dumps(error_response))
            
        elif command == 'get_recent_data':
            # Get recent CSV data for main chart with 2-hour intervals
            try:
                files = self.sensor_service.get_file_list()
                print(f"Total CSV files available: {len(files)}")
                
                # Get more recent files and sort by modification time to get the latest data
                recent_files = files[:50]  # Get more files to ensure we capture very recent data
                
                all_data = []
                files_loaded = 0
                
                for filename in recent_files:
                    if files_loaded >= 20:  # Limit to prevent overwhelming
                        break
                    try:
                        csv_data = await self.load_csv_data(filename)
                        if csv_data:  # Only add if data exists
                            # For recent data, sample less aggressively to show real-time trends
                            sampled_data = csv_data[::max(1, len(csv_data)//20)] if len(csv_data) > 20 else csv_data
                            all_data.extend(sampled_data)
                            files_loaded += 1
                            print(f"Loaded {len(sampled_data)} points from {filename}")
                    except Exception as e:
                        print(f"Error loading {filename}: {e}")
                        continue
                
                # Sort by timestamp to ensure chronological order
                all_data.sort(key=lambda x: x['timestamp'])
                
                # Get the most recent data points (last 3000 for better coverage)
                all_data = all_data[-3000:] if len(all_data) > 3000 else all_data
                
                print(f"Total data points prepared: {len(all_data)}")
                if all_data:
                    print(f"Data range: {all_data[0]['timestamp']} to {all_data[-1]['timestamp']}")
                
                response = {
                    "type": "recent_data",
                    "data": all_data,
                    "file_count": files_loaded
                }
                await websocket.send(json.dumps(response))
                print(f"Sent {len(all_data)} data points from {files_loaded} files for 2-hour interval display")
                
            except Exception as e:
                print(f"Error in get_recent_data: {str(e)}")
                error_response = {
                    "type": "error",
                    "message": f"Failed to load recent data: {str(e)}"
                }
                await websocket.send(json.dumps(error_response))
            
        elif command == 'export_all_csv_zip':
            print(f"Received ZIP export request from client")
            try:
                zip_info = await self.create_csv_zip_export()
                print(f"ZIP export successful: {zip_info['filename']} with {zip_info['file_count']} files")
                response = {
                    "type": "zip_export",
                    "download_url": zip_info['url'],
                    "filename": zip_info['filename'],
                    "file_count": zip_info['file_count']
                }
                await websocket.send(json.dumps(response))
                print(f"ZIP export response sent to client")
            except Exception as e:
                print(f"ZIP export failed: {str(e)}")
                import traceback
                traceback.print_exc()
                error_response = {
                    "type": "zip_export",
                    "error": f"Failed to create ZIP export: {str(e)}"
                }
                await websocket.send(json.dumps(error_response))
            
        else:
            error_response = {
                "type": "error",
                "message": f"Unknown command: {command}"
            }
            await websocket.send(json.dumps(error_response))
    
    async def monitor_csv_files(self):
        """Monitor CSV files and notify clients of new files"""
        while self.running:
            try:
                current_file_count = len(list(self.readings_dir.glob("*.csv")))
                
                if current_file_count != self.last_file_count:
                    self.last_file_count = current_file_count
                    
                    # Notify clients of new file
                    latest_file = self.sensor_service.get_latest_file()
                    if latest_file:
                        notification = {
                            "type": "new_file",
                            "filename": latest_file,
                            "total_files": current_file_count
                        }
                        await self.send_to_all_clients(json.dumps(notification))
                
                await asyncio.sleep(1)  # Check every second
                
            except Exception as e:
                print(f"Error monitoring CSV files: {e}")
                await asyncio.sleep(5)
    
    async def handle_client(self, websocket):
        """Handle individual WebSocket client"""
        await self.register_client(websocket)
        
        try:
            async for message in websocket:
                try:
                    data = json.loads(message)
                    await self.handle_command(websocket, data)
                except json.JSONDecodeError:
                    error_response = {
                        "type": "error",
                        "message": "Invalid JSON format"
                    }
                    await websocket.send(json.dumps(error_response))
                except Exception as e:
                    error_response = {
                        "type": "error",
                        "message": f"Command error: {str(e)}"
                    }
                    await websocket.send(json.dumps(error_response))
                    
        except websockets.exceptions.ConnectionClosed:
            pass
        except Exception as e:
            print(f"Client handler error: {e}")
        finally:
            await self.unregister_client(websocket)
    
    async def periodic_status_update(self):
        """Send periodic status updates to all clients"""
        while self.running:
            await asyncio.sleep(5)  # Every 5 seconds
            if self.clients:
                await self.send_status_update()
    
    async def start_server(self):
        """Start the WebSocket server and all background tasks"""
        self.running = True
        
        # Ensure directories exist
        self.readings_dir.mkdir(exist_ok=True)
        self.download_dir.mkdir(exist_ok=True)
        
        # Start HTTP server for file downloads
        self.start_http_server()
        
        # Start sensor service
        self.sensor_service.start()
        
        # Start background tasks
        file_monitor_task = asyncio.create_task(self.monitor_csv_files())
        status_update_task = asyncio.create_task(self.periodic_status_update())
        
        # Start WebSocket server
        server = await websockets.serve(self.handle_client, "localhost", 8765)
        print("High-Speed WebSocket server started on ws://localhost:8765")
        print(f"HTTP download server started on http://localhost:{self.http_port}")
        print("Commands supported:")
        print("  - get_status: Get current status")
        print("  - start_collection/stop_collection: Control data collection")
        print("  - get_file_list: Get list of CSV files")
        print("  - get_csv_data: Load specific CSV file data")
        print("  - get_recent_data: Load recent data for 2-hour interval chart")
        print("  - export_all_csv_zip: Export all CSV files as ZIP")
        
        try:
            await server.wait_closed()
        finally:
            self.running = False
            self.sensor_service.stop()
            self.stop_http_server()

if __name__ == "__main__":
    server = HighSpeedWebSocketServer()
    try:
        asyncio.run(server.start_server())
    except KeyboardInterrupt:
        print("\nServer stopped")
    except Exception as e:
        print(f"Server error: {e}")#!/usr/bin/env python3
"""
Enhanced WebSocket server with high-speed sensor service integration
"""

import asyncio
import websockets
import json
import os
import csv
import zipfile
import tempfile
from datetime import datetime
from pathlib import Path
from high_speed_sensor_service import HighSpeedSensorService
import threading
from http.server import HTTPServer, SimpleHTTPRequestHandler
import socketserver
from urllib.parse import unquote
import shutil

class HighSpeedWebSocketServer:
    def __init__(self):
        self.clients = set()
        self.sensor_service = HighSpeedSensorService()
        self.running = False
        self.readings_dir = Path("readings")
        self.last_file_count = 0
        self.download_dir = Path("downloads")
        self.download_dir.mkdir(exist_ok=True)
        self.http_server = None
        self.http_port = 8766
        
    async def register_client(self, websocket):
        """Register a new WebSocket client"""
        self.clients.add(websocket)
        print(f"Client connected. Total clients: {len(self.clients)}")
        
        # Send initial status
        await self.send_status_update(websocket)
        
    async def unregister_client(self, websocket):
        """Unregister a WebSocket client"""
        if websocket in self.clients:
            self.clients.remove(websocket)
        print(f"Client disconnected. Total clients: {len(self.clients)}")
        
    async def load_csv_data(self, filename):
        """Load CSV data from file"""
        try:
            return self.sensor_service.load_csv_data(filename)
        except Exception as e:
            raise Exception(f"Error reading CSV file: {str(e)}")
    
    async def create_csv_zip_export(self):
        """Create a ZIP file containing all CSV files in their hierarchical structure"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        zip_filename = f"sensor_data_export_{timestamp}.zip"
        
        # Create ZIP file in downloads directory
        zip_path = self.download_dir / zip_filename
        
        print(f"Creating ZIP export at: {zip_path}")
        print(f"Scanning directory: {self.readings_dir}")
        
        file_count = 0
        
        # Check if readings directory exists
        if not self.readings_dir.exists():
            raise Exception(f"Readings directory {self.readings_dir} does not exist")
        
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # Add all CSV files maintaining the exact hierarchical structure
            csv_files = list(self.readings_dir.rglob("*.csv"))
            print(f"Found {len(csv_files)} CSV files to export")
            
            for csv_file in csv_files:
                if csv_file.is_file():
                    try:
                        # Get relative path from readings directory to maintain folder structure
                        relative_path = csv_file.relative_to(self.readings_dir)
                        # Add to ZIP with the full folder structure (Year/Month/Week/Day/file.csv)
                        zipf.write(csv_file, f"sensor_data/{relative_path}")
                        file_count += 1
                        print(f"Added to ZIP: sensor_data/{relative_path}")
                    except Exception as e:
                        print(f"Warning: Failed to add {csv_file} to ZIP: {e}")
                        continue
            
            # Add a summary file at the root of the ZIP
            summary_content = f"""Wilo Sensor Data Export Summary
=================================
Export Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total Files: {file_count}
Data Structure: sensor_data/Year/Month/Week_N/Day/HHMMSS.csv

File Format:
- Time (ms): Milliseconds within file second (e.g., 0.223ms, 3.2122ms)
- Acceleration: m/sÂ² (float)

Directory Structure:
- Year: 4-digit year (e.g., 2024)
- Month: 2-digit month (e.g., 01-12)
- Week_N: Week number within the month (e.g., Week_1, Week_2, etc.)
- Day: 2-digit day (e.g., 01-31)
- HHMMSS.csv: Hour, minute, second of the data file

Generated by Wilo Cloud Monitoring System
"""
            zipf.writestr("README.txt", summary_content)
        
        print(f"ZIP file created successfully with {file_count} files")
        
        # Verify the ZIP file was created
        if not zip_path.exists():
            raise Exception("ZIP file was not created successfully")
        
        file_size = zip_path.stat().st_size
        print(f"ZIP file size: {file_size} bytes")
        
        # Create HTTP download URL
        download_url = f"http://localhost:{self.http_port}/{zip_filename}"
        
        return {
            'url': download_url,
            'filename': zip_filename,
            'file_count': file_count,
            'path': str(zip_path),
            'size': file_size
        }
    
    def start_http_server(self):
        """Start HTTP server to serve download files"""
        try:
            class DownloadHandler(SimpleHTTPRequestHandler):
                def __init__(self, *args, **kwargs):
                    # Set the directory to serve files from
                    self.downloads_dir = str(self.server.downloads_dir)
                    super().__init__(*args, directory=self.downloads_dir, **kwargs)
                
                def end_headers(self):
                    # Add headers for ZIP file downloads
                    if self.path.endswith('.zip'):
                        self.send_header('Content-Type', 'application/zip')
                        self.send_header('Content-Disposition', f'attachment; filename="{os.path.basename(self.path)}"')
                    super().end_headers()
                
                def log_message(self, format, *args):
                    # Suppress HTTP server logs
                    pass
            
            # Create a custom HTTPServer that passes the downloads directory
            class CustomHTTPServer(HTTPServer):
                def __init__(self, server_address, handler_class, downloads_dir):
                    self.downloads_dir = downloads_dir
                    super().__init__(server_address, handler_class)
            
            self.http_server = CustomHTTPServer(('localhost', self.http_port), DownloadHandler, self.download_dir)
            print(f"HTTP download server started on http://localhost:{self.http_port}")
            
            # Run HTTP server in a separate thread
            def run_server():
                self.http_server.serve_forever()
            
            http_thread = threading.Thread(target=run_server, daemon=True)
            http_thread.start()
            
        except Exception as e:
            print(f"Failed to start HTTP server: {e}")
    
    def stop_http_server(self):
        """Stop HTTP server"""
        if self.http_server:
            self.http_server.shutdown()
            self.http_server = None
    
    async def send_to_all_clients(self, message):
        if self.clients:
            disconnected = []
            for client in self.clients:
                try:
                    await client.send(message)
                except websockets.exceptions.ConnectionClosed:
                    disconnected.append(client)
                except Exception as e:
                    print(f"Error sending to client: {e}")
                    disconnected.append(client)
            
            # Remove disconnected clients
            for client in disconnected:
                self.clients.discard(client)
    
    async def send_status_update(self, websocket=None):
        """Send status update to client(s)"""
        status = self.sensor_service.get_status()
        
        status_message = {
            "type": "status",
            "data": {
                "connected": status['connected'],
                "sampling_rate": status['sampling_rate'],
                "total_samples": status['total_samples'],
                "csv_files": status['csv_stats']['total_files'],
                "latest_file": self.sensor_service.get_latest_file()
            }
        }
        
        message = json.dumps(status_message)
        
        if websocket:
            try:
                await websocket.send(message)
            except:
                pass
        else:
            await self.send_to_all_clients(message)
    
    async def handle_command(self, websocket, command_data):
        """Handle commands from frontend"""
        command = command_data.get('command')
        
        if command == 'get_status':
            await self.send_status_update(websocket)
            
        elif command == 'start_collection':
            self.sensor_service.start()
            await self.send_status_update()
            
        elif command == 'stop_collection':
            self.sensor_service.stop()
            await self.send_status_update()
            
        elif command == 'pause_collection':
            self.sensor_service.pause()
            await self.send_status_update()
            
        elif command == 'resume_collection':
            self.sensor_service.resume()
            await self.send_status_update()
            
        elif command == 'get_file_list':
            files = self.sensor_service.get_file_list()
            response = {
                "type": "file_list",
                "files": files  # Return full list; frontend can paginate if needed
            }
            await websocket.send(json.dumps(response))
            
        elif command == 'get_folder_structure':
            structure = self.sensor_service.get_folder_structure()
            response = {
                "type": "folder_structure",
                "structure": structure
            }
            await websocket.send(json.dumps(response))
            
        elif command == 'get_csv_data':
            filename = command_data.get('filename')
            if filename:
                try:
                    csv_data = await self.load_csv_data(filename)
                    response = {
                        "type": "csv_data",
                        "filename": filename,
                        "data": csv_data
                    }
                    await websocket.send(json.dumps(response))
                except Exception as e:
                    error_response = {
                        "type": "error",
                        "message": f"Failed to load CSV file {filename}: {str(e)}"
                    }
                    await websocket.send(json.dumps(error_response))
            else:
                error_response = {
                    "type": "error",
                    "message": "CSV filename not provided"
                }
                await websocket.send(json.dumps(error_response))
            
        elif command == 'get_recent_data':
            # Get recent CSV data for main chart with 2-hour intervals
            try:
                files = self.sensor_service.get_file_list()
                print(f"Total CSV files available: {len(files)}")
                
                # Get more recent files and sort by modification time to get the latest data
                recent_files = files[:50]  # Get more files to ensure we capture very recent data
                
                all_data = []
                files_loaded = 0
                
                for filename in recent_files:
                    if files_loaded >= 20:  # Limit to prevent overwhelming
                        break
                    try:
                        csv_data = await self.load_csv_data(filename)
                        if csv_data:  # Only add if data exists
                            # For recent data, sample less aggressively to show real-time trends
                            sampled_data = csv_data[::max(1, len(csv_data)//20)] if len(csv_data) > 20 else csv_data
                            all_data.extend(sampled_data)
                            files_loaded += 1
                            print(f"Loaded {len(sampled_data)} points from {filename}")
                    except Exception as e:
                        print(f"Error loading {filename}: {e}")
                        continue
                
                # Sort by timestamp to ensure chronological order
                all_data.sort(key=lambda x: x['timestamp'])
                
                # Get the most recent data points (last 3000 for better coverage)
                all_data = all_data[-3000:] if len(all_data) > 3000 else all_data
                
                print(f"Total data points prepared: {len(all_data)}")
                if all_data:
                    print(f"Data range: {all_data[0]['timestamp']} to {all_data[-1]['timestamp']}")
                
                response = {
                    "type": "recent_data",
                    "data": all_data,
                    "file_count": files_loaded
                }
                await websocket.send(json.dumps(response))
                print(f"Sent {len(all_data)} data points from {files_loaded} files for 2-hour interval display")
                
            except Exception as e:
                print(f"Error in get_recent_data: {str(e)}")
                error_response = {
                    "type": "error",
                    "message": f"Failed to load recent data: {str(e)}"
                }
                await websocket.send(json.dumps(error_response))
            
        elif command == 'export_all_csv_zip':
            print(f"Received ZIP export request from client")
            try:
                zip_info = await self.create_csv_zip_export()
                print(f"ZIP export successful: {zip_info['filename']} with {zip_info['file_count']} files")
                response = {
                    "type": "zip_export",
                    "download_url": zip_info['url'],
                    "filename": zip_info['filename'],
                    "file_count": zip_info['file_count']
                }
                await websocket.send(json.dumps(response))
                print(f"ZIP export response sent to client")
            except Exception as e:
                print(f"ZIP export failed: {str(e)}")
                import traceback
                traceback.print_exc()
                error_response = {
                    "type": "zip_export",
                    "error": f"Failed to create ZIP export: {str(e)}"
                }
                await websocket.send(json.dumps(error_response))
            
        else:
            error_response = {
                "type": "error",
                "message": f"Unknown command: {command}"
            }
            await websocket.send(json.dumps(error_response))
    
    async def monitor_csv_files(self):
        """Monitor CSV files and notify clients of new files"""
        while self.running:
            try:
                current_file_count = len(list(self.readings_dir.glob("*.csv")))
                
                if current_file_count != self.last_file_count:
                    self.last_file_count = current_file_count
                    
                    # Notify clients of new file
                    latest_file = self.sensor_service.get_latest_file()
                    if latest_file:
                        notification = {
                            "type": "new_file",
                            "filename": latest_file,
                            "total_files": current_file_count
                        }
                        await self.send_to_all_clients(json.dumps(notification))
                
                await asyncio.sleep(1)  # Check every second
                
            except Exception as e:
                print(f"Error monitoring CSV files: {e}")
                await asyncio.sleep(5)
    
    async def handle_client(self, websocket):
        """Handle individual WebSocket client"""
        await self.register_client(websocket)
        
        try:
            async for message in websocket:
                try:
                    data = json.loads(message)
                    await self.handle_command(websocket, data)
                except json.JSONDecodeError:
                    error_response = {
                        "type": "error",
                        "message": "Invalid JSON format"
                    }
                    await websocket.send(json.dumps(error_response))
                except Exception as e:
                    error_response = {
                        "type": "error",
                        "message": f"Command error: {str(e)}"
                    }
                    await websocket.send(json.dumps(error_response))
                    
        except websockets.exceptions.ConnectionClosed:
            pass
        except Exception as e:
            print(f"Client handler error: {e}")
        finally:
            await self.unregister_client(websocket)
    
    async def periodic_status_update(self):
        """Send periodic status updates to all clients"""
        while self.running:
            await asyncio.sleep(5)  # Every 5 seconds
            if self.clients:
                await self.send_status_update()
    
    async def start_server(self):
        """Start the WebSocket server and all background tasks"""
        self.running = True
        
        # Ensure directories exist
        self.readings_dir.mkdir(exist_ok=True)
        self.download_dir.mkdir(exist_ok=True)
        
        # Start HTTP server for file downloads
        self.start_http_server()
        
        # Start sensor service
        self.sensor_service.start()
        
        # Start background tasks
        file_monitor_task = asyncio.create_task(self.monitor_csv_files())
        status_update_task = asyncio.create_task(self.periodic_status_update())
        
        # Start WebSocket server
        server = await websockets.serve(self.handle_client, "localhost", 8765)
        print("High-Speed WebSocket server started on ws://localhost:8765")
        print(f"HTTP download server started on http://localhost:{self.http_port}")
        print("Commands supported:")
        print("  - get_status: Get current status")
        print("  - start_collection/stop_collection: Control data collection")
        print("  - get_file_list: Get list of CSV files")
        print("  - get_csv_data: Load specific CSV file data")
        print("  - get_recent_data: Load recent data for 2-hour interval chart")
        print("  - export_all_csv_zip: Export all CSV files as ZIP")
        
        try:
            await server.wait_closed()
        finally:
            self.running = False
            self.sensor_service.stop()
            self.stop_http_server()

if __name__ == "__main__":
    server = HighSpeedWebSocketServer()
    try:
        asyncio.run(server.start_server())
    except KeyboardInterrupt:
        print("\nServer stopped")
    except Exception as e:
        print(f"Server error: {e}")